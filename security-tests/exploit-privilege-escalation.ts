/**
 * PRIVILEGE ESCALATION TEST SUITE
 * 
 * Tests for:
 * 1. Vertical Privilege Escalation (user -> admin)
 * 2. Horizontal Privilege Escalation (user A -> user B's data)
 * 3. IDOR (Insecure Direct Object Reference)
 * 4. Role manipulation in requests
 * 5. Admin endpoint access
 * 
 * âš ï¸ FOR AUTHORIZED SECURITY TESTING ONLY
 */

import axios, { AxiosError } from 'axios';

const API_BASE = 'https://api.security-test.site/api/v1';

// ============================================
// CONFIGURATION - Update with real tokens
// ============================================

// Regular user token (get from login)
const USER_TOKEN = 'YOUR_USER_JWT_TOKEN_HERE';

// Another user's ID (to test horizontal escalation)
const OTHER_USER_ID = '507f1f77bcf86cd799439011';

// Admin-only endpoints to test
const ADMIN_ENDPOINTS = [
  { method: 'GET', path: '/users' },
  { method: 'GET', path: '/orders' },
  { method: 'GET', path: '/analytics/dashboard' },
  { method: 'GET', path: '/audit/logs' },
  { method: 'PATCH', path: `/users/${OTHER_USER_ID}` },
  { method: 'DELETE', path: `/users/${OTHER_USER_ID}` },
  { method: 'PATCH', path: '/orders/507f1f77bcf86cd799439011/status' },
];

// User-specific endpoints (for IDOR testing)
const USER_ENDPOINTS = [
  { method: 'GET', path: `/users/${OTHER_USER_ID}` },
  { method: 'GET', path: `/orders/${OTHER_USER_ID}` },
  { method: 'GET', path: `/users/${OTHER_USER_ID}/orders` },
];

const api = axios.create({
  baseURL: API_BASE,
  timeout: 10000,
  validateStatus: () => true, // Don't throw on any status
});

const printHeader = (title: string) => {
  console.log('\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
  console.log(`â•‘     ${title.padEnd(55)}â•‘`);
  console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
};

const printSubHeader = (title: string) => {
  console.log(`\nğŸ”“ ${title}`);
  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
};

// ============================================
// TEST 1: Vertical Privilege Escalation
// Try to access admin endpoints with user token
// ============================================
async function testVerticalEscalation() {
  printHeader('TEST 1: Vertical Privilege Escalation');
  console.log('Attempting to access admin endpoints with regular user token...\n');

  if (USER_TOKEN === 'YOUR_USER_JWT_TOKEN_HERE') {
    console.log('âš ï¸  WARNING: No user token configured!');
    console.log('   Update USER_TOKEN with a real user JWT token.\n');
    console.log('   Testing without authentication (should all fail)...\n');
  }

  const results: { endpoint: string; status: number; blocked: boolean }[] = [];

  for (const endpoint of ADMIN_ENDPOINTS) {
    try {
      const response = await api.request({
        method: endpoint.method as 'GET' | 'POST' | 'PATCH' | 'DELETE',
        url: endpoint.path,
        headers: {
          'Authorization': `Bearer ${USER_TOKEN}`,
          'Content-Type': 'application/json',
        },
        data: endpoint.method !== 'GET' ? { status: 'paid' } : undefined,
      });

      const blocked = [401, 403, 404].includes(response.status);
      results.push({
        endpoint: `${endpoint.method} ${endpoint.path}`,
        status: response.status,
        blocked,
      });

      const icon = blocked ? 'âœ…' : 'ğŸš¨';
      const statusText = blocked ? 'BLOCKED' : 'ACCESSIBLE!';
      console.log(`   ${icon} ${endpoint.method} ${endpoint.path}`);
      console.log(`      Status: ${response.status} - ${statusText}`);
      
      if (!blocked) {
        console.log(`      ğŸš¨ CRITICAL: Admin endpoint accessible by regular user!`);
        console.log(`      Response: ${JSON.stringify(response.data).substring(0, 100)}...`);
      }
    } catch (err) {
      console.log(`   âŒ ${endpoint.method} ${endpoint.path} - Error: ${(err as Error).message}`);
    }
  }

  const vulnerableCount = results.filter(r => !r.blocked).length;
  console.log('\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
  console.log(`RESULT: ${vulnerableCount === 0 ? 'âœ… SECURE' : `ğŸš¨ ${vulnerableCount} VULNERABLE ENDPOINTS`}`);
  
  return vulnerableCount === 0;
}

// ============================================
// TEST 2: Horizontal Privilege Escalation (IDOR)
// Try to access other users' data
// ============================================
async function testHorizontalEscalation() {
  printHeader('TEST 2: Horizontal Privilege Escalation (IDOR)');
  console.log('Attempting to access other users\' data...\n');

  if (USER_TOKEN === 'YOUR_USER_JWT_TOKEN_HERE') {
    console.log('âš ï¸  Skipping - requires valid user token\n');
    return true;
  }

  const results: { endpoint: string; status: number; vulnerable: boolean }[] = [];

  for (const endpoint of USER_ENDPOINTS) {
    try {
      const response = await api.request({
        method: endpoint.method as 'GET',
        url: endpoint.path,
        headers: {
          'Authorization': `Bearer ${USER_TOKEN}`,
        },
      });

      // If we get 200 with data, it might be IDOR vulnerability
      const vulnerable = response.status === 200 && response.data?.data;
      results.push({
        endpoint: `${endpoint.method} ${endpoint.path}`,
        status: response.status,
        vulnerable,
      });

      if (vulnerable) {
        console.log(`   ğŸš¨ ${endpoint.method} ${endpoint.path}`);
        console.log(`      Status: ${response.status} - ACCESSIBLE!`);
        console.log(`      Data returned for another user's resource!`);
      } else {
        console.log(`   âœ… ${endpoint.method} ${endpoint.path}`);
        console.log(`      Status: ${response.status} - Protected`);
      }
    } catch (err) {
      console.log(`   âŒ ${endpoint.method} ${endpoint.path} - Error`);
    }
  }

  const vulnerableCount = results.filter(r => r.vulnerable).length;
  console.log('\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
  console.log(`RESULT: ${vulnerableCount === 0 ? 'âœ… SECURE' : `ğŸš¨ ${vulnerableCount} IDOR VULNERABILITIES`}`);
  
  return vulnerableCount === 0;
}

// ============================================
// TEST 3: Role Manipulation in Request Body
// Try to set role=admin in registration/update
// ============================================
async function testRoleManipulation() {
  printHeader('TEST 3: Role Manipulation in Requests');
  console.log('Attempting to inject admin role in requests...\n');

  const testCases: Array<{
    name: string;
    method: string;
    path: string;
    data: Record<string, unknown>;
    requiresAuth?: boolean;
  }> = [
    {
      name: 'Registration with role=admin',
      method: 'POST',
      path: '/auth/register',
      data: {
        email: `hacker_${Date.now()}@test.com`,
        password: 'SecurePass123!',
        name: 'Hacker',
        role: 'admin',
      },
    },
    {
      name: 'Registration with isAdmin=true',
      method: 'POST',
      path: '/auth/register',
      data: {
        email: `hacker2_${Date.now()}@test.com`,
        password: 'SecurePass123!',
        name: 'Hacker2',
        isAdmin: true,
      },
    },
    {
      name: 'Update profile with role escalation',
      method: 'PATCH',
      path: '/users/me',
      data: {
        name: 'Updated Name',
        role: 'admin',
      },
      requiresAuth: true,
    },
    {
      name: 'Update with prototype pollution for role',
      method: 'PATCH',
      path: '/users/me',
      data: {
        name: 'Test',
        '__proto__': { role: 'admin' },
        'constructor': { 'prototype': { role: 'admin' } },
      },
      requiresAuth: true,
    },
  ];

  for (const test of testCases) {
    console.log(`[*] ${test.name}`);
    
    try {
      const headers: Record<string, string> = {
        'Content-Type': 'application/json',
      };
      
      if (test.requiresAuth && USER_TOKEN !== 'YOUR_USER_JWT_TOKEN_HERE') {
        headers['Authorization'] = `Bearer ${USER_TOKEN}`;
      }

      const response = await api.request({
        method: test.method as 'POST' | 'PATCH',
        url: test.path,
        headers,
        data: test.data,
      });

      console.log(`    Status: ${response.status}`);
      
      // Check if role was actually set to admin
      if (response.data?.data?.role === 'admin' || response.data?.user?.role === 'admin') {
        console.log(`    ğŸš¨ CRITICAL: Role escalation successful!`);
        console.log(`    Response: ${JSON.stringify(response.data)}`);
      } else if (response.status === 201 || response.status === 200) {
        console.log(`    âœ… Request accepted but role not escalated`);
        if (response.data?.data?.role) {
          console.log(`    Assigned role: ${response.data.data.role}`);
        }
      } else {
        console.log(`    âœ… Request rejected or role stripped`);
      }
    } catch (err) {
      console.log(`    âŒ Error: ${(err as Error).message}`);
    }
    console.log();
  }
}

// ============================================
// TEST 4: JWT Claims Manipulation
// Try forged tokens with admin claims
// ============================================
async function testJWTClaimsManipulation() {
  printHeader('TEST 4: JWT Claims Manipulation');
  console.log('Testing forged JWTs with escalated claims...\n');

  // Create fake JWT with admin role (won't have valid signature)
  const fakePayload = {
    sub: '507f1f77bcf86cd799439011',
    email: 'admin@fake.com',
    role: 'admin',
    iat: Math.floor(Date.now() / 1000),
    exp: Math.floor(Date.now() / 1000) + 3600,
  };

  const base64Payload = Buffer.from(JSON.stringify(fakePayload)).toString('base64url');
  const fakeHeader = Buffer.from(JSON.stringify({ alg: 'HS256', typ: 'JWT' })).toString('base64url');
  const fakeSignature = 'fake_signature_here';
  
  const forgedToken = `${fakeHeader}.${base64Payload}.${fakeSignature}`;

  console.log('[1] Testing forged token with admin role...');
  console.log(`    Payload: ${JSON.stringify(fakePayload)}`);

  try {
    const response = await api.get('/users', {
      headers: {
        'Authorization': `Bearer ${forgedToken}`,
      },
    });

    if (response.status === 200) {
      console.log('    ğŸš¨ CRITICAL: Forged admin token accepted!');
    } else {
      console.log(`    âœ… Rejected with status ${response.status}`);
    }
  } catch (err) {
    console.log(`    âœ… Request failed (expected)`);
  }

  // Test with empty/null role
  console.log('\n[2] Testing token with manipulated role values...');
  
  const roleTests = [
    { role: 'ADMIN', desc: 'uppercase ADMIN' },
    { role: 'Admin', desc: 'mixed case Admin' },
    { role: 'admin ', desc: 'admin with trailing space' },
    { role: ' admin', desc: 'admin with leading space' },
    { role: 'administrator', desc: 'administrator' },
    { role: 'superuser', desc: 'superuser' },
    { role: 'root', desc: 'root' },
  ];

  for (const test of roleTests) {
    const payload = { ...fakePayload, role: test.role };
    const b64 = Buffer.from(JSON.stringify(payload)).toString('base64url');
    const token = `${fakeHeader}.${b64}.${fakeSignature}`;

    const resp = await api.get('/users', {
      headers: { 'Authorization': `Bearer ${token}` },
    });

    const icon = resp.status === 401 ? 'âœ…' : 'ğŸš¨';
    console.log(`    ${icon} role="${test.role}" (${test.desc}): ${resp.status}`);
  }
}

// ============================================
// TEST 5: Parameter Pollution for Privilege Escalation
// ============================================
async function testParameterPollution() {
  printHeader('TEST 5: Parameter Pollution');
  console.log('Testing HTTP Parameter Pollution for privilege escalation...\n');

  const tests = [
    {
      name: 'Duplicate role parameter',
      path: '/auth/register?role=user&role=admin',
      data: { email: `hpp_${Date.now()}@test.com`, password: 'Test123!', name: 'HPP Test' },
    },
    {
      name: 'Array role parameter',
      path: '/auth/register',
      data: { 
        email: `arr_${Date.now()}@test.com`, 
        password: 'Test123!', 
        name: 'Array Test',
        role: ['user', 'admin'],
      },
    },
    {
      name: 'Object role parameter',
      path: '/auth/register',
      data: { 
        email: `obj_${Date.now()}@test.com`, 
        password: 'Test123!', 
        name: 'Object Test',
        role: { '$gt': '' },  // NoSQL injection attempt
      },
    },
  ];

  for (const test of tests) {
    console.log(`[*] ${test.name}`);
    
    try {
      const response = await api.post(test.path, test.data, {
        headers: { 'Content-Type': 'application/json' },
      });

      console.log(`    Status: ${response.status}`);
      
      if (response.data?.data?.role === 'admin') {
        console.log(`    ğŸš¨ CRITICAL: Admin role assigned!`);
      } else {
        console.log(`    âœ… Role not escalated (role: ${response.data?.data?.role || 'N/A'})`);
      }
    } catch (err) {
      console.log(`    âœ… Request rejected`);
    }
    console.log();
  }
}

// ============================================
// TEST 6: Mass Assignment Vulnerability
// ============================================
async function testMassAssignment() {
  printHeader('TEST 6: Mass Assignment Vulnerability');
  console.log('Testing if server accepts unexpected fields that could escalate privileges...\n');

  const dangerousFields = [
    'role',
    'isAdmin',
    'admin',
    'permissions',
    'privileges',
    'accessLevel',
    'userType',
    'accountType',
    'verified',
    'emailVerified',
    'twoFactorEnabled',
    'tokenVersion',
    'password', // Should not be updatable via regular update
    '_id',
    'id',
    'createdAt',
    'updatedAt',
  ];

  console.log('Attempting to set dangerous fields via profile update...\n');

  if (USER_TOKEN === 'YOUR_USER_JWT_TOKEN_HERE') {
    console.log('âš ï¸  Requires valid user token. Testing registration instead...\n');

    // Test via registration
    const regData: Record<string, unknown> = {
      email: `mass_${Date.now()}@test.com`,
      password: 'SecurePass123!',
      name: 'Mass Assignment Test',
    };

    // Add all dangerous fields
    for (const field of dangerousFields) {
      regData[field] = field === 'role' ? 'admin' : true;
    }

    try {
      const response = await api.post('/auth/register', regData);
      console.log(`Registration status: ${response.status}`);
      
      if (response.data?.data) {
        const userData = response.data.data;
        console.log('\nReturned user data:');
        for (const field of dangerousFields) {
          if (userData[field] !== undefined) {
            const expected = field === 'role' ? 'user' : false;
            const actual = userData[field];
            const safe = (field === 'role' && actual === 'user') || 
                        (field !== 'role' && (actual === false || actual === undefined));
            const icon = safe ? 'âœ…' : 'ğŸš¨';
            console.log(`  ${icon} ${field}: ${JSON.stringify(actual)}`);
          }
        }
      }
    } catch (err) {
      console.log(`Error: ${(err as Error).message}`);
    }
  } else {
    // Test via profile update
    const updateData: Record<string, unknown> = { name: 'Updated' };
    for (const field of dangerousFields) {
      updateData[field] = field === 'role' ? 'admin' : true;
    }

    try {
      const response = await api.patch('/users/me', updateData, {
        headers: {
          'Authorization': `Bearer ${USER_TOKEN}`,
          'Content-Type': 'application/json',
        },
      });

      console.log(`Update status: ${response.status}`);
      
      if (response.data?.data) {
        console.log('\nFields in response (check if dangerous fields were accepted):');
        for (const field of dangerousFields) {
          if (response.data.data[field] !== undefined) {
            console.log(`  ${field}: ${JSON.stringify(response.data.data[field])}`);
          }
        }
      }
    } catch (err) {
      console.log(`Error: ${(err as Error).message}`);
    }
  }
}

// ============================================
// MAIN
// ============================================
async function main() {
  console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
  console.log('â•‘     PRIVILEGE ESCALATION TEST SUITE                          â•‘');
  console.log('â•‘     Target: https://api.security-test.site                   â•‘');
  console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  console.log('\nâš ï¸  This is for authorized security testing only!\n');

  const results: { test: string; passed: boolean }[] = [];

  // Run all tests
  results.push({ test: 'Vertical Privilege Escalation', passed: await testVerticalEscalation() });
  results.push({ test: 'Horizontal Privilege Escalation', passed: await testHorizontalEscalation() });
  
  await testRoleManipulation();
  await testJWTClaimsManipulation();
  await testParameterPollution();
  await testMassAssignment();

  // Final summary
  printHeader('FINAL SUMMARY');
  console.log('Privilege Escalation Test Results:\n');
  
  for (const result of results) {
    const icon = result.passed ? 'âœ…' : 'ğŸš¨';
    console.log(`  ${icon} ${result.test}: ${result.passed ? 'SECURE' : 'VULNERABLE'}`);
  }

  console.log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  console.log('RECOMMENDATIONS:');
  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  console.log('1. Use Joi/Zod with stripUnknown to remove unexpected fields');
  console.log('2. Never trust client-provided role/permission fields');
  console.log('3. Implement proper RBAC with middleware checks');
  console.log('4. Use parameterized queries to prevent injection');
  console.log('5. Validate JWT signature AND claims on every request');
  console.log('6. Log and alert on privilege escalation attempts');
}

main().catch(console.error);
